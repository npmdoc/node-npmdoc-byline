<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/jahewson/node-byline">byline (v5.0.0)</a>
</h1>
<h4>simple line-by-line stream reader</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.byline">module byline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.byline">
            function <span class="apidocSignatureSpan"></span>byline
            <span class="apidocSignatureSpan">(readStream, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.LineStream">
            function <span class="apidocSignatureSpan">byline.</span>LineStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.createLineStream">
            function <span class="apidocSignatureSpan">byline.</span>createLineStream
            <span class="apidocSignatureSpan">(readStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.createStream">
            function <span class="apidocSignatureSpan">byline.</span>createStream
            <span class="apidocSignatureSpan">(readStream, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">byline.</span>LineStream.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.byline.LineStream">module byline.LineStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.LineStream.LineStream">
            function <span class="apidocSignatureSpan">byline.</span>LineStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.LineStream.super_">
            function <span class="apidocSignatureSpan">byline.LineStream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.byline.LineStream.prototype">module byline.LineStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.LineStream.prototype._flush">
            function <span class="apidocSignatureSpan">byline.LineStream.prototype.</span>_flush
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.LineStream.prototype._pushBuffer">
            function <span class="apidocSignatureSpan">byline.LineStream.prototype.</span>_pushBuffer
            <span class="apidocSignatureSpan">(encoding, keep, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.LineStream.prototype._reencode">
            function <span class="apidocSignatureSpan">byline.LineStream.prototype.</span>_reencode
            <span class="apidocSignatureSpan">(line, chunkEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.byline.LineStream.prototype._transform">
            function <span class="apidocSignatureSpan">byline.LineStream.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, done)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.byline" id="apidoc.module.byline">module byline</a></h1>


    <h2>
        <a href="#apidoc.element.byline.byline" id="apidoc.element.byline.byline">
        function <span class="apidocSignatureSpan"></span>byline
        <span class="apidocSignatureSpan">(readStream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byline = function (readStream, options) {
  return module.exports.createStream(readStream, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.byline.LineStream" id="apidoc.element.byline.LineStream">
        function <span class="apidocSignatureSpan">byline.</span>LineStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LineStream(options) {
  stream.Transform.call(this, options);
  options = options || {};

  // use objectMode to stop the output from being buffered
  // which re-concatanates the lines, just without newlines.
  this._readableState.objectMode = true;
  this._lineBuffer = [];
  this._keepEmptyLines = options.keepEmptyLines || false;
  this._lastChunkEndedWithCR = false;

  // take the source's encoding if we don't have one
  var self = this;
  this.on('pipe', function(src) {
    if (!self.encoding) {
      // but we can't do this for old-style streams
      if (src instanceof stream.Readable) {
        self.encoding = src._readableState.encoding;
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.byline.createLineStream" id="apidoc.element.byline.createLineStream">
        function <span class="apidocSignatureSpan">byline.</span>createLineStream
        <span class="apidocSignatureSpan">(readStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createLineStream = function (readStream) {
  console.log('WARNING: byline#createLineStream is deprecated and will be removed soon');
  return createLineStream(readStream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.byline.createStream" id="apidoc.element.byline.createStream">
        function <span class="apidocSignatureSpan">byline.</span>createStream
        <span class="apidocSignatureSpan">(readStream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createStream = function (readStream, options) {
  if (readStream) {
    return createLineStream(readStream, options);
  } else {
    return new LineStream(options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
You just need to add one line to wrap your readable `Stream` with a `LineStream`.

```javascript
var fs = require('fs'),	
    byline = require('byline');

var stream = fs.createReadStream('sample.txt');
stream = byline.<span class="apidocCodeKeywordSpan">createStream</span>(stream);

stream.on('data', function(line) {
  console.log(line);
});
```

# Piping
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.byline.LineStream" id="apidoc.module.byline.LineStream">module byline.LineStream</a></h1>


    <h2>
        <a href="#apidoc.element.byline.LineStream.LineStream" id="apidoc.element.byline.LineStream.LineStream">
        function <span class="apidocSignatureSpan">byline.</span>LineStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LineStream(options) {
  stream.Transform.call(this, options);
  options = options || {};

  // use objectMode to stop the output from being buffered
  // which re-concatanates the lines, just without newlines.
  this._readableState.objectMode = true;
  this._lineBuffer = [];
  this._keepEmptyLines = options.keepEmptyLines || false;
  this._lastChunkEndedWithCR = false;

  // take the source's encoding if we don't have one
  var self = this;
  this.on('pipe', function(src) {
    if (!self.encoding) {
      // but we can't do this for old-style streams
      if (src instanceof stream.Readable) {
        self.encoding = src._readableState.encoding;
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.byline.LineStream.super_" id="apidoc.element.byline.LineStream.super_">
        function <span class="apidocSignatureSpan">byline.LineStream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.byline.LineStream.prototype" id="apidoc.module.byline.LineStream.prototype">module byline.LineStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.byline.LineStream.prototype._flush" id="apidoc.element.byline.LineStream.prototype._flush">
        function <span class="apidocSignatureSpan">byline.LineStream.prototype.</span>_flush
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (done) {
  this._pushBuffer(this._chunkEncoding, 0, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.byline.LineStream.prototype._pushBuffer" id="apidoc.element.byline.LineStream.prototype._pushBuffer">
        function <span class="apidocSignatureSpan">byline.LineStream.prototype.</span>_pushBuffer
        <span class="apidocSignatureSpan">(encoding, keep, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pushBuffer = function (encoding, keep, done) {
  // always buffer the last (possibly partial) line
  while (this._lineBuffer.length &gt; keep) {
    var line = this._lineBuffer.shift();
    // skip empty lines
    if (this._keepEmptyLines || line.length &gt; 0 ) {
      if (!this.push(this._reencode(line, encoding))) {
        // when the high-water mark is reached, defer pushes until the next tick
        var self = this;
        timers.setImmediate(function() {
          self._pushBuffer(encoding, keep, done);
        });
        return;
      }
    }
  }
  done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this._lineBuffer.length &gt; 0) {
  this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
  lines.shift();
}

this._lastChunkEndedWithCR = chunk[chunk.length - 1] == '\r';
this._lineBuffer = this._lineBuffer.concat(lines);
this.<span class="apidocCodeKeywordSpan">_pushBuffer</span>(encoding, 1, done);
};

LineStream.prototype._pushBuffer = function(encoding, keep, done) {
// always buffer the last (possibly partial) line
while (this._lineBuffer.length &gt; keep) {
  var line = this._lineBuffer.shift();
  // skip empty lines
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.byline.LineStream.prototype._reencode" id="apidoc.element.byline.LineStream.prototype._reencode">
        function <span class="apidocSignatureSpan">byline.LineStream.prototype.</span>_reencode
        <span class="apidocSignatureSpan">(line, chunkEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_reencode = function (line, chunkEncoding) {
  if (this.encoding &amp;&amp; this.encoding != chunkEncoding) {
    return new Buffer(line, chunkEncoding).toString(this.encoding);
  }
  else if (this.encoding) {
    // this should be the most common case, i.e. we're using an encoded source stream
    return line;
  }
  else {
    return new Buffer(line, chunkEncoding);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

LineStream.prototype._pushBuffer = function(encoding, keep, done) {
// always buffer the last (possibly partial) line
while (this._lineBuffer.length &gt; keep) {
  var line = this._lineBuffer.shift();
  // skip empty lines
  if (this._keepEmptyLines || line.length &gt; 0 ) {
    if (!this.push(this.<span class="apidocCodeKeywordSpan">_reencode</span>(line, encoding))) {
      // when the high-water mark is reached, defer pushes until the next tick
      var self = this;
      timers.setImmediate(function() {
        self._pushBuffer(encoding, keep, done);
      });
      return;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.byline.LineStream.prototype._transform" id="apidoc.element.byline.LineStream.prototype._transform">
        function <span class="apidocSignatureSpan">byline.LineStream.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, done) {
  // decode binary chunks as UTF-8
  encoding = encoding || 'utf8';

  if (Buffer.isBuffer(chunk)) {
    if (encoding == 'buffer') {
      chunk = chunk.toString(); // utf8
      encoding = 'utf8';
    }
    else {
     chunk = chunk.toString(encoding);
    }
  }
  this._chunkEncoding = encoding;

  // see: http://www.unicode.org/reports/tr18/#Line_Boundaries
  var lines = chunk.split(/\r\n|[\n\v\f\r\x85\u2028\u2029]/g);

  // don't split CRLF which spans chunks
  if (this._lastChunkEndedWithCR &amp;&amp; chunk[0] == '\n') {
    lines.shift();
  }

  if (this._lineBuffer.length &gt; 0) {
    this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
    lines.shift();
  }

  this._lastChunkEndedWithCR = chunk[chunk.length - 1] == '\r';
  this._lineBuffer = this._lineBuffer.concat(lines);
  this._pushBuffer(encoding, 1, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>